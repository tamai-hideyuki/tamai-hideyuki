# TypeScriptの歴史と設計トレードオフ

## なぜ生まれたか
TypeScriptは「大規模なJavaScript開発を楽にする」ことを目的に、JavaScriptの**上位互換（typed superset）**として設計された。型を追加しつつ、最終的には**JavaScriptへコンパイル**される。

## 簡単な年表（主要マイルストーン）
- **2012年10月1日**: TypeScriptが初めて公に公開された。  
- **2014年4月2日**: TypeScript 1.0が発表。

## 主要バージョンの流れ（代表機能）
- **2.0**: **制御フローに基づく型解析**が導入され、`strictNullChecks` と密接に連動。
- **3.0**: **Project References** と `--build` が追加され、大規模プロジェクトの分割と高速化を支援。
- **4.1**: **テンプレートリテラル型**が追加され、文字列型の表現力が拡張。
- **4.9**: **`satisfies` 演算子**が追加され、型検証と推論の両立が容易に。

## 現在の形に至った主なトレードオフ

### 1. 互換性重視（JavaScriptの書き方に合わせる）
TypeScriptの**型互換性は構造的型付け（structural typing）**で、型の互換性は「メンバーが揃っているか」で判断される。

- **メリット**: 既存のJSコードやライブラリと馴染みやすい
- **デメリット（推論）**: 構造が同じなら互換になるため、意図しない代入が起きる場合がある

### 2. 実用性重視（完全な型安全よりも使いやすさ）
TypeScriptの設計目標では、**完全な健全性（soundness）を最優先しない**ことが明言されている。これは、既存のJavaScriptコードとの互換性や実用性を重視するトレードオフ。

- **メリット**: 既存コードの移行や現場パターンに対応しやすい
- **デメリット（推論）**: 型チェックをすり抜けるケースがあり、実行時エラーにつながることがある

### 3. “上位互換”という制約
TypeScriptはJavaScriptの**上位互換**であり、最終的に**JavaScriptへコンパイル**される。型情報はコンパイル時に消えるため、ランタイムには残らない。

- **メリット**: 既存のJS資産をそのまま活かせる
- **デメリット（推論）**: 型は開発時の補助に限定され、実行時の保証は別途必要

## まとめ
TypeScriptは「既存のJavaScript資産と開発体験を重視しつつ、型で規模拡大に耐えられるようにする」という目的で進化してきた。**互換性と実用性を優先する設計**が、今の形の土台になっている。
